/* Проект hexprn.
Преобразует массив байт в шестнадцатеричный вид (наподобие как в просмотрщике)
с возможностью задания формата преобразования.
Состав:
  hexprn.h
  hexprn.c
Используется статическая библиотека elements

Описание:
hexprn - статическая библиотека для преобразования двоичного содержимого памяти в строки символов.
Строка символов показывает состояние двоичного содержимого памяти без/с указанием адреса, к примеру в виде:

0000FFA0: ** ** ** 41 | 42 43 44 45 | 46 01 48 90 | 4A ** ** ** |    ABCDEF H J

или так:

0000FFA0: -- -- -- 41 42 43 44 45 | 46 01 48 90 4A -- -- -- | +++A|BCDE|F.H.|J++|

или так:

0000FFA0: хх хх хх 41 42 43 44 45 " 46 01 48 90 4A хх хх хх "    ABCDEF?H?J

или так:

хх хх хх 41 42 43 44 45 " 46 01 48 90 4A хх хх хх "    ABCDEF?H?J

или так:

хххххх41 42434445 46014890 4Aхххххх

или так:

4142434445460148904A

вообщем, возможны различные варианты формата вывода.

Описание примера:
Задан массив байт byte_array { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x01, 0x48, 0x90, 0x4A, ... }.
Адрес, соответствующий нулевому элементу массива - 0000FFA3.
Число элементов массива для преобразования - 10.
*/
#ifndef HEXPRN_H
#define HEXPRN_H

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "elements.h"

/* Структура, определяющая результат преобразования
Внимание! Значения ограничены INT_MAX */
struct Trans_Result
{
	int byte_count;  // число преобразованных байтов
	int char_count;  // число выведенных символов
	int str_count;   // число преобразованных адресных строк
	size_t single_length; // длина одной адресной строки с учетом добавочной строки
	size_t add_length;   // длина добавочной строки
};

/* структура, определяющая формат преобразования одной строки */
struct Trans_Format
{
	/* параметры печати адреса */
	int prn_address;   // печатать адрес: != 0 да, == 0 нет

	/* параметры вывода пустых ячеек */
	byte empty_value;  // на что заменить значение пустой ячейки
	char empty_hex;    // какой символ отображает шестнадцатеричное значение пустых ячеек
	char empty_ascii;  // какой символ отображает ascii значение пустых ячеек

	/* параметры вывода шестнадцатеричных значений ячеек */
	char hex_char_delimeter;    // разделитель между выведенными элементами, если '\0' или CHAR_DEL, то не ставится
	char hex_block_delimeter;   // разделитель между группами элементов, если '\0' или CHAR_DEL, то не ставится
	size_t hex_block_length;    // длина группы элементов, между которыми ставится символ '|', если 0, то не ставится

	/* параметры вывода ascii значений ячеек */
	char ascii_char_delimeter;  // разделитель между выведенными элементами, если '\0' или CHAR_DEL, то не ставится
	char ascii_block_delimeter; // разделитель между группами элементов, если '\0' или CHAR_DEL, то не ставится
	size_t ascii_block_length;  // длина группы элементов, между которыми ставится символ '|', если 0, то не ставится
	char non_print_char;        // какой символ показывает непечатаемые значения
};

/* четыре функции для преобразования: 

 hexprn()  вывод на экран n байт из массива байт без смещения со стандартным форматом вывода
 fhexprn() вывод в файл n байт из массива байт с задаваемым адресом со стандартным форматом вывода
 shexprn() вывод в строку n байт из массива байт с задаваемым адресом со стандартным форматом вывода
 shexprn_formatted() вывод в строку n байт из массива байт с задаваемым форматом вывода
 
*/

/* Выводит на экран n байтов.
Преобразует массив байт byte_array длиной byte_count в массив символов и записывает его
в стандартное устройство вывода stdout. Формат преобразования - по-умолчанию, смещения адреса нет.
Возвращает число выведенных символов в формате возврата. */
struct Trans_Result hexprn(byte *byte_array, size_t byte_count);

/* Выводит в файл (можно в stdout) n байт.
Преобразует массив байт byte_array длиной byte_count в строку
и записывает её в файл fp. Формат преобразования - по-умолчанию, 
смещение адреса нулевого элемента массива - address.
Возвращает число выведенных символов в формате возврата. */
struct Trans_Result fhexprn(FILE *fp, byte *byte_array, size_t byte_count, word address);

/* Преобразует массив байт длиной byte_count в массив символов (последовательность адресных строк)
с форматом по-умолчанию. Выделяет необходимую память для строки *s. 
Перед использованием необходимо выделить память s = (char **) malloc(sizof(char **));
Когда строка не нужна, требуется освободить память в таком порядке: free(*s); free(s); */
struct Trans_Result shexprn(char **s, byte *byte_array, size_t byte_count, word address_start);
/* Преобразование массива байт длиной byte_count в последовательность адресных строк и записывает их в s.
Параметры:
	s              - указатель на указатель, куда будет записываться строка
	byte_array     - массив исходных байт
	byte_count     - наибольшее число байт для преобразования, ограничивается hex_max_count()
	address_start  - адрес (смещение) нулевого элемента массива byte_array
Возвращает структуру Trans_Result.
*/

/* Преобразование массива байт длиной byte_count в в массив символов (последовательность адресных строк)
 с заданным форматом.
 Перед работой требуется подситать предварительный ожидаемый результат before_tr посредством calc_tr_result()
 */
struct Trans_Result shexprnf(char *s, byte *byte_array, size_t byte_count, \
	word address_start, struct Trans_Format *tf, char *insert_str, struct Trans_Result before_tr);
/* Преобразование массива байт длиной byte_count в последовательность адресных строк и запись их в s.
Параметры:
	s              - символьная строка для записи
	byte_array     - массив исходных байт
	byte_count     - наибольшее число байт для преобразования, ограничивается hex_max_count()
	address_start  - адрес (смещение) нулевого элемента массива byte_array
	tf             - формат преобразования
	insert_str     - строка, которая будет вставляться после каждой преобразованной адресной строки,
	                 допустим "\r\n" или "\n", если NULL, то без вставки
	before_tr      - предварительный результат всего преобразования согласно возврату calc_tr_result()
Возвращает структуру:
	Trans_Result.char_count:
	    < 0   ошибка
	    > 0   число записанных символов
	Trans_Result.byte_count:
	    <  0  ошибка
	    >= 0  число преобразованных байт, не более результата hex_max_count()
	Trans_Result.str_count:
	    <= 0  ошибка
	    >  0  число преобразованныз строк
	Trans_Result.single_length
	    == 0  ошибка
	    >  0  длина одной преобразованной строки с учетом длины добавочной строки
	Внимание! Значения полей возвращаемой структуры ограничены INT_MAX,
  проверка на переполнение не производится.
*/

/* возврат формата вывода по умолчанию */
struct Trans_Format ret_default_tf();

/* печать результатов преобразования tr в файл fp */
int fprint_tr(FILE *fp, struct Trans_Result *tr);

/* печать результатов преобразования tr в стандартный вывод stdout */
int print_tr(struct Trans_Result *tr);

/* Подсчет и возврат количества символов для вывода одной
адресной строки в формате tf */
size_t calc_chars_tf(struct Trans_Format *tf);

/* Проверяет ограничение числа байт для преобразования count
по перекрытию наибольшего доступного адреса WORD_MAX.
Должно выполняться неравенство:
	max_count <= WORD_MAX + 1 - address
Наибольшее количество ячеек, если начальный адрес равен нулю, тогда возможно ячеек WORD_MAX + 1.
Во всех других случаях число байт <= WORD_MAX.
*/
size_t hex_max_count(size_t count, word address);

/* Определение, сколько адресных строк требуется для преобразования массива байт.
Преобразование байт в общем случае может идти с перехлестом.
Перед вызовом этой функции необходимо подавать число байт, ограниченное hex_max_count(). */
size_t hex_addr_str(size_t count, word address);

/* Подсчитывает и возвращает предполагаемый результат преобразования массива байт
byte_array длиной count в последовательность адресных строк s.
Внимание! Значения полей возвращаемой структуры ограничены INT_MAX, проверка на переполнение не производится.  */
struct Trans_Result calc_tr_result(size_t byte_count, word address_start,
        struct Trans_Format *tf, char *insert_str);
/* Подсчитывает и возвращает предполагаемый результат преобразования массива байт.
Параметры:
	byte_count     - наибольшее число байт для преобразования, ограничивается hex_max_count()
	address_start  - адрес (смещение) нулевого элемента массива byte_array
	tf             - формат преобразования
	insert_str     - строка, которая будет вставляться после каждой преобразованной адресной строки,
	                 допустим "\r\n" или "\n", если NULL, то без вставки
Возвращает структуру:
	Trans_Result.char_count:
	     < 0  ошибка
	     > 0  необходимое число символов, для записи в строку s с учетом строки insert_str
	Trans_Result.byte_count:
	     < 0  ошибка
	    >= 0  число преобразованных байт, ограничивается hex_max_count()
	Trans_Result.str_count:
		<= 0  ошибка
	   	 > 0  предполагаемое число строк для преобразования
	Trans_Result.single_length
		== 0  ошибка
	   	 > 0  предполагаемая длина одной преобразованной строки с учетом длины добавочной строки
	Внимание! Значения полей возвращаемой структуры ограничены INT_MAX, проверка на переполнение не производится.
*/

#endif //HEX_PRN_H